**Fixora ‚Äì Smart Urban Grievance Redressal System**

Fixora is a centralized, transparent, and real-time grievance redressal system designed to help Urban Local Bodies efficiently address citizen complaints. Built using Flutter for cross-platform accessibility and Firebase for seamless backend operations, Fixora enables users to easily submit issues while allowing authorities to track, manage, and resolve them with complete accountability.

---


## Recent Work (Dec 2025)

### Raise Issue Page Enhancements

- **Added Terms & Conditions Checkbox**: Implemented a styled checkbox field that users must check before submitting a complaint. This ensures users acknowledge and agree to provide accurate information and accept the Fixora Terms & Conditions.
  - **Checkbox State Management**: New boolean state variable `_agreeToTerms` tracks the checkbox status.
  - **Submit Button Lock**: The submit button is now disabled until the checkbox is checked, preventing accidental or false submissions.
  - **Form Reset**: After successful submission, the checkbox is automatically unchecked along with other form fields, preparing the form for the next complaint entry.
  - **Visual Design**: The checkbox has a styled container with a blue border that changes color when selected, matching the app's blue theme (primary color: #2563EB).
  - **Implementation Location**: [lib/pages/raise_issue/raise_issue_page.dart](lib/pages/raise_issue/raise_issue_page.dart)

**How it works:**
1. User fills in all complaint details (category, issue, description, location).
2. Before submitting, user must check the "I agree to provide accurate information and accept the Fixora Terms & Conditions" checkbox.
3. The submit button changes from disabled (grayed out) to enabled only when the checkbox is checked.
4. After successful submission, a success message is shown with the complaint ID and the form is cleared (including unchecking the checkbox).
5. User can now submit another complaint if needed.

### Previous Work (Earlier Dec 2025)

- Added status and category filters on the Track Complaint page with client-side filtering to avoid Firestore composite index requirements.
- Implemented edge-aware overlay menus for filters and a streamlined "View Tracking Details" bottom sheet sized for shorter content (heights at 0.45/0.35/0.8 for large/medium/full views).
- Tuned typography for complaint details (smaller body text, preserved title size) and tightened padding to reduce visual clutter.
- Primary changes live in [lib/pages/track_complaint/track_complaint_page.dart](lib/pages/track_complaint/track_complaint_page.dart).

## Complaints & Tracking (Dec 2025)

Recent implementation highlights:
- **Complaint ID generation**: Every submission generates an ID in the format `CG-YYYY-XXXXXX` (e.g., CG-2025-001234). Implemented in [lib/pages/raise_issue/raise_issue_page.dart](lib/pages/raise_issue/raise_issue_page.dart).
- **Firestore storage**: Complaints are stored in the `problems` collection with fields such as `complaintId`, `userId`, `category`, `issue`, `description`, `location`, `status`, and `createdAt`.
- **Track page data**: [lib/pages/track_complaint/track_complaint_page.dart](lib/pages/track_complaint/track_complaint_page.dart) streams all complaints (ordered by `createdAt`) and renders cards with status chips.
- **Search by ID**: The Track page search box looks up `complaintId` and shows the current status.
- **Debug seeding**: In debug builds, a helper seeds a sample complaint (ID: CG-2025-001234) and the ‚ÄúCreate Sample Complaint (Debug)‚Äù button can insert another test entry for the logged-in user.
- **Demo chips**: Sample IDs are displayed under ‚ÄúTry these demo tracking IDs‚Äù for quick manual entry.

How to test quickly:
1) Run the app (web example):
```bash
flutter run -d chrome
```
2) Navigate to the Track page (`/track`).
3) Enter an ID (try CG-2025-001234) and press ‚ÄúTrack‚Äù to see status.
4) (Optional) Click ‚ÄúCreate Sample Complaint (Debug)‚Äù to insert a fresh test complaint, then track the shown ID.
5) To submit a real complaint, open the report page (`/report`); it will auto-generate a new `complaintId` and save to Firestore.


---

## Setting Up Flutter SDK, Android Studio, and First Emulator Run

Welcome to your first setup deliverable of Sprint #2! In this foundational task, you'll install and configure the Flutter SDK, set up Android Studio (or VS Code) for development, and run your first Flutter app on an emulator or physical device. This step establishes your complete development environment for all upcoming Flutter and Firebase integrations in this sprint.

**Note:** These are general setup guidelines. You may complete the setup on Windows, macOS, or Linux, depending on your system preferences and requirements.

### Task Overview

**1. Install Flutter SDK**

- Visit the official Flutter installation page for your operating system.
- Download and extract the Flutter SDK to a preferred directory (e.g., `C:\src\flutter` or `/Users/yourname/development/flutter`).
- Add Flutter to your systems PATH environment variable.

**Windows:**
- Search for "Environment Variables" ‚Üí Edit PATH ‚Üí Add `flutter\bin`.

**macOS/Linux:**
- Open terminal and edit your shell profile (e.g., `.zshrc` or `.bashrc`):
    bash
  export PATH="$PATH:`pwd`/flutter/bin"

- Verify installation by running:
  ```bash
  flutter doctor
  ```
  This command checks your setup and lists missing dependencies.

**2. Set Up Android Studio (or VS Code)**

- Install Android Studio from the official website.
- During installation, ensure the following components are checked:
  - Android SDK
  - Android SDK Platform
  - Android Virtual Device (AVD) Manager
- Open Android Studio ‚Üí Plugins ‚Üí search for and install Flutter and Dart plugins.

**Alternatively, if using VS Code:**
- Install Flutter and Dart extensions from the Marketplace.

**3. Configure Your Emulator**

In Android Studio:
- Open AVD Manager ‚Üí Create Virtual Device.
- Choose a device (e.g., Pixel 6) and a system image (Android 13 or above).
- Click Finish and launch the emulator.

Verify that your emulator is detected by running:

```
bash
flutter devices
```
The emulator should appear in the device list.

**4. Create and Run Your First Flutter App**

- Create a new Flutter project:

  ```bash
  flutter create first_flutter_app
  ```
- Navigate to the project folder and open it in Android Studio or VS Code.
- Run the app on your emulator or connected physical device:

  ```bash
  flutter run
  ```
- You should see the default Flutter counter app appear on your emulator screen.

**5. Setup Verification**

We have successfully completed the Flutter environment setup with the following evidence:

- **Flutter Doctor Output**: All required dependencies are installed and configured correctly
- **Emulator Running**: The Android emulator is successfully running the first Flutter app

**Screenshots:**
- Flutter Devices Detection: `screenshot/result_of_flutter_device.png`
- Android Emulator Running: `screenshot/android_emulator.png`

**Setup Images (2025-12-17):**
![Setup image 1](screenshot/Screenshot%202025-12-17%20153633.png)
![Setup image 2](screenshot/Screenshot%202025-12-17%20153645.png)

**Setup Completion Notes:**
- Flutter SDK has been successfully installed and added to PATH
- Android Studio configured with Flutter and Dart plugins
- Android Virtual Device (AVD) created and tested
- First Flutter app successfully runs on the emulator
- Development environment is ready for upcoming Flutter and Firebase integrations


## Folder Structure

lib/
‚îÇ
‚îú‚îÄ‚îÄ main.dart
‚îÇ
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login_page.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register_page.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_dashboard.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ submit_complaint_page.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tracking_complaint_page.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ complaint_categories_page.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_profile_page.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ admin/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ admin_dashboard_page.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ home_page.dart
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ splash/
‚îÇ       ‚îî‚îÄ‚îÄ splash_screen.dart
‚îÇ
‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îú‚îÄ‚îÄ custom_button.dart
‚îÇ   ‚îú‚îÄ‚îÄ custom_textfield.dart
‚îÇ   ‚îú‚îÄ‚îÄ complaint_card.dart
‚îÇ   ‚îî‚îÄ‚îÄ dashboard_tile.dart
‚îÇ
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ user_model.dart
‚îÇ   ‚îî‚îÄ‚îÄ complaint_model.dart
‚îÇ
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ auth_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ complaint_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ admin_service.dart
‚îÇ   ‚îî‚îÄ‚îÄ firestore_service.dart
‚îÇ
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ app_colors.dart
‚îÇ   ‚îú‚îÄ‚îÄ app_styles.dart
‚îÇ   ‚îú‚îÄ‚îÄ app_routes.dart
‚îÇ   ‚îî‚îÄ‚îÄ constants.dart
‚îÇ
‚îî‚îÄ‚îÄ providers/
    ‚îú‚îÄ‚îÄ user_provider.dart
    ‚îî‚îÄ‚îÄ complaint_provider.dart

## Exploring Flutter Project Folder Structure and Understanding File Roles

## Project Title

Flutter Project Folder Structure Overview

A simple project setup showcasing how the Flutter folder structure works and why understanding it helps in app development.

---

## Project Structure Summary

For a detailed explanation, check **PROJECT_STRUCTURE.md**.

```
lib/
‚îú‚îÄ‚îÄ main.dart
‚îú‚îÄ‚îÄ screens/
‚îú‚îÄ‚îÄ widgets/
‚îî‚îÄ‚îÄ services/
```

This is the main working directory where all Dart code lives.

---

## Folder View (IDE Screenshot Placeholder)

> Add your folder screenshot here.

---

## Reflection

### Why understand folder roles?

* Helps navigate the project faster.
* Makes it easier to debug and add new features.

### How does clean structure help teams?

* Every member knows where files belong.
* Reduces confusion and merge conflicts.
* Improves scalability and maintainability.


## Flutter & Dart Basics (Concept 1)

# 1. StatelessWidget vs StatefulWidget

StatelessWidget:

Does not change once it is built.

Used for static UI like text, icons, simple layouts.

StatefulWidget:

Can change during the app‚Äôs lifetime.

Used when the UI updates, like counters, text fields, or API data.

# 2. How Flutter Uses the Widget Tree

Flutter builds everything as a widget tree.

Each widget is a small part of the UI.

When something changes (like a button press), Flutter rebuilds only the affected widgets.

This makes the UI fast and reactive.

# 3. Why Dart Is Ideal for Flutter

Dart compiles fast and gives smooth performance.

Supports hot reload, so changes appear instantly.

Works well for both UI and logic, making development simple.

# 4. Demo App Notes (Android / iOS)

Our demo app showed a simple screen with text and a button.

Pressing the button updated the counter (StatefulWidget).

Screenshot -1
**Refer to screenshot folder for proof of work(concept-1.png)**

### Firebase & Firestore Basics (Concept 2)

**1. Steps Followed for Firebase Setup**

Created a new project in Firebase Console.

Enabled Firestore Database.

Added Firebase to the Flutter app using the setup instructions.

Downloaded the google-services.json (Android) / GoogleService-Info.plist (iOS).

Added required Firebase dependencies in pubspec.yaml.

Initialized Firebase in the app using Firebase.initializeApp().

**2.How Firestore‚Äôs Real-Time Sync Works**

Firestore sends updates to the app instantly whenever data changes.

The app listens to the database using streams (like StreamBuilder).

No need to refresh‚Äîthe UI updates automatically when Firestore data changes.

This works because Firestore uses real-time listeners under the hood.

**Demo Logs / Notes Showing Live Updates**

**Refer to screenshot folder for proof of work(concept-2.png)**

**4. Reflection ‚Äì How Firebase Simplified Backend Management**

No need to build your own server or database.

Firestore handled real-time data, storage, and syncing for us.

Authentication, hosting, and database all came ready to use.

This allowed us to focus more on UI and features instead of backend code.

Firebase helped build a working mobile app much faster and with less complexity.

Here is a **short, clean, human-written version** you can directly paste into your README:

---

## Flutter Development Tools Overview

### **1. Hot Reload**

Hot Reload lets you apply UI and code changes instantly without restarting the app.
Just run the app (`flutter run`), edit a widget, save the file, and the update appears immediately.
This makes UI development much faster and keeps the app state intact.
screenshot/hot_reload.png
screenshot/hot_reload_After.png

### **2. Debug Console**

I used the Debug Console to monitor logs, catch errors, and track variable changes using `print()` or `debugPrint()`.
It helps understand how the app behaves while running and is useful for quick debugging.

### **3. Flutter DevTools**

DevTools was used to inspect widgets, check layouts, view performance graphs, and analyze memory usage.
I opened it directly from VS Code using **Ctrl + Shift + P ‚Üí Flutter: Open DevTools** while the app was running.
screenshot/dev_tools.png

### **4. Workflow**

My workflow was simple:

* Update UI ‚Üí Hot Reload to see immediate changes
* Add logs ‚Üí View results in Debug Console
* Open DevTools ‚Üí Inspect widgets & performance

### **Reflection**

Hot Reload improved development speed, the Debug Console helped catch issues early, and DevTools made it easier to understand widget structure and optimize performance.


## Authentication & User Dashboard (Concept 2.5)

**Overview: Login, Register & Dashboard Implementation**

We have created a complete authentication flow with responsive UI for mobile, tablet, and desktop devices.

**1. Login & Register Pages**

Created `login_register_page.dart` with the following features:

- **Dual Form UI**: Single component handles both login and registration modes
- **Form Validation**: Email and password validation with error messages
- **Responsive Design**: Adaptive UI that adjusts padding, font sizes, and button heights based on screen size
- **Form Switching**: Easy toggle between login and register modes using the "Don't have an account?" / "Already have an account?" buttons
- **Flutter StatefulWidget**: Uses form validation with GlobalKey to ensure user inputs are valid before submission

**Key Features:**

- Input validation for email, password, and username (registration only)
- Responsive card design with elevation effects
- Centered layout using SingleChildScrollView and ConstrainedBox
- TextFormField for email (with keyboard type), password (obscured), and username
- ElevatedButton with dynamic sizing

**Screenshots:**

- Login Screen: `screenshot/login_screen.png`
- Register Screen: `screenshot/register_screen.png`
- Home Screen: `screenshot/home_screen.png`

**2. User Dashboard**

Created `user_dashboard.dart` with the following features:

- **Welcome Message**: Personalized greeting with user icon
- **Account Information Display**: Shows logged-in user's email and username
- **Logout Functionality**: Profile menu button in AppBar with logout confirmation dialog
- **Responsive Layout**: Matches login page design for consistency
- **Navigation Integration**: Receives user data via route arguments

**Key Features:**

- Displays user email and username from login/register form
- PopupMenuButton for user profile actions
- Confirmation dialog before logout
- Clears navigation history on logout (user cannot go back to dashboard)
- Professional card-based UI with proper spacing
- Fully responsive for all screen sizes

**Navigation Flow:**

1. Home Page ‚Üí "Login / Register" button
2. Login/Register Page ‚Üí Enter credentials ‚Üí "Login" or "Register" button
3. User Dashboard ‚Üí Shows welcome message + user info
4. Logout ‚Üí Returns to Home Page

## Figma & Design Thinking (Concept 3)

Concept 3 : [Concept-3] Design Thinking for Smart Mobile Interfaces Using Figma & Flutter

Figma link added in README: https://www.figma.com/design/oVfHrUu16qlP7QhvimqI5o/Untitled?node-id=21-2&t=mO2EKGZKPWgBHT9P-1

Creating the High-Level Design (HLD) for Fixora

The High-Level Design (HLD) gives an overview of how the Urban Grievance Redressal System is structured. It explains the main parts of the app, how they connect, and how data flows through the system. This helps in understanding the project‚Äôs architecture before moving into detailed implementation.

What the HLD Includes

1. Frontend (Flutter App)

Main screens: Splash, Login, Dashboard, Add Complaint, Complaint Status, Profile.

Simple navigation flow between screens.

Use of state management (like Provider, Riverpod, or Bloc).

Reusable UI components for consistency.

2. Backend (Firebase Services)

Firebase Authentication for secure login (Email/Google).

Cloud Firestore to store user data, complaints, and status updates.

Cloud Storage for uploading photos/videos of issues.

Cloud Functions for sending notifications and automating backend tasks.

3. Data Models

User: id, name, email, role.

Complaint: title, description, category, location, media, status, timestamps.

Updates: timeline of changes for each complaint.

4. Integrations

Google Maps API for selecting and viewing locations.

Firebase Cloud Messaging (FCM) for real-time notifications.

Analytics & Crashlytics for tracking usage and app crashes.

5. CI/CD & Deployment

Automated build and deploy pipelines using GitHub Actions or Codemagic.

Support for multiple environments (dev / staging / production).

The HLD also includes a visual diagram showing how all layers connect.

Here is the figma link:

https://www.figma.com/design/oVfHrUu16qlP7QhvimqI5o/Untitled?node-id=19-2&t=tA9gbpPbYfdawzYP-1

# Firebase SDK Integration (FlutterFire CLI)

## Overview

Firebase SDKs were integrated into a Flutter app using **FlutterFire CLI** for fast and error-free multi-platform setup.

## Steps

```bash
npm install -g firebase-tools
dart pub global activate flutterfire_cli
firebase login
flutterfire configure
```

Generated `firebase_options.dart` automatically.

## Firebase Initialization

```dart
await Firebase.initializeApp(
  options: DefaultFirebaseOptions.currentPlatform,
);
```

## Verification

* App runs successfully
* Firebase Console shows registered app
* Log confirms Firebase initialization

## Reflection

FlutterFire CLI simplified setup, avoided manual configuration, and ensured platform consistency.


Setup completed successfully

---

## Data Requirements List

The application needs to store:

**User**
- userId
- username
- email
- password

**Problem**
- problemId
- userId (reference to user)
- category
- description
- priority
- status
- image
- location

---

## Firestore Schema Design

### üîπ Collections Overview

- **users**
- **problems**

---

### Users Collection

```
users (collection)
 ‚îî‚îÄ‚îÄ userId (document)
       ‚îú‚îÄ‚îÄ username: string
       ‚îú‚îÄ‚îÄ email: string
       ‚îú‚îÄ‚îÄ password: string
       ‚îî‚îÄ‚îÄ createdAt: timestamp
```

**Sample User Document:**

```json
{
  "username": "guna_priya",
  "email": "guna@example.com",
  "password": "hashed_password",
  "createdAt": "2025-02-10T10:30:00Z"
}
```

---

### Problems Collection

```
problems (collection)
 ‚îî‚îÄ‚îÄ problemId (document)
       ‚îú‚îÄ‚îÄ userId: string
       ‚îú‚îÄ‚îÄ category: string
       ‚îú‚îÄ‚îÄ description: string
       ‚îú‚îÄ‚îÄ priority: string
       ‚îú‚îÄ‚îÄ status: string
       ‚îú‚îÄ‚îÄ imageUrl: string
       ‚îú‚îÄ‚îÄ location: map
       ‚îÇ      ‚îú‚îÄ‚îÄ latitude: number
       ‚îÇ      ‚îî‚îÄ‚îÄ longitude: number
       ‚îú‚îÄ‚îÄ createdAt: timestamp
       ‚îî‚îÄ‚îÄ updatedAt: timestamp
```

**Sample Problem Document:**

```json
{
  "userId": "user_001",
  "category": "Water",
  "description": "Water leakage near street corner",
  "priority": "High",
  "status": "Pending",
  "imageUrl": "https://firebase.storage/water_issue.jpg",
  "location": {
    "latitude": 12.9716,
    "longitude": 77.5946
  },
  "createdAt": "2025-02-10T11:00:00Z",
  "updatedAt": "2025-02-10T11:00:00Z"
}
```

---

### Relationships

- Each problem stores `userId` to link it with the user who reported it.
- This avoids large arrays and supports efficient querying.

---

### Schema Diagram

Example structure:

```
users ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îî‚îÄ‚îÄ problems (linked via userId)
```

---

### Schema Validation Checklist

‚úî Matches application requirements  
‚úî Scales to large user bases  
‚úî Uses proper data types  
‚úî Avoids deeply nested structures  
‚úî Easy to understand and maintain  

---

### Reflection

**Why this structure?**

- Separate collections improve scalability.
- Using `userId` references avoids duplication.
- Image URLs reduce document size.

**Performance & Scalability**

- Supports fast queries using indexed fields.
- Firestore real-time updates improve user experience.
- No document size limit issues.

**Challenges Faced**

- Choosing between subcollections and top-level collections.
- Designing location data efficiently.
- Keeping the schema simple but extensible.

## Firestore Write Operations (Flutter)

This module demonstrates how to safely write data to Cloud Firestore from a Flutter application.

#### What‚Äôs Covered

Adding new documents to Firestore

Updating existing documents without overwriting data

Using structured and scalable write operations

Validating user input before saving

Handling Firestore errors gracefully

### Outcome

By completing this task, the app can reliably store and update user-generated data (such as complaints or profiles) while ensuring data safety, consistency, and proper error handling.

### Creating a Basic CRUD Flow with Flutter, Firestore, and Auth

This module focuses on building a complete CRUD (Create, Read, Update, Delete) flow using Flutter,
Firebase Authentication, and Cloud Firestore, which together form a powerful stack for modern mobile application development.
The goal is to demonstrate how real-world applications manage user data securely while maintaining a responsive and intuitive user interface.

Firebase Authentication is used to identify and authorize users, ensuring that only authenticated users can access and interact with the application‚Äôs data.
Cloud Firestore acts as the primary database, storing structured data and providing real-time updates that automatically reflect changes in the UI without requiring manual refreshes.

The Admin Dashboard showcases how data can be read and displayed in real time, filtered based on status or search criteria,
updated through user actions, and managed efficiently using Firestore queries. The UI is built to handle loading, empty,
and error states gracefully, creating a smooth and reliable user experience.

Overall, this implementation follows common industry practices by clearly separating UI components, authentication logic, and database operations. It serves as a practical example of how Flutter applications can scale while remaining maintainable, secure, and responsive.


## Securing Firebase with Authentication and Firestore Rules

This implementation strengthens application security by combining Firebase Authentication with Firestore Security Rules to ensure that only authorized users can access and modify data.

### Authentication

Firebase Authentication is used to manage user sign-in.

Only authenticated users are allowed to interact with Firestore.

User identity is verified using Firebase-issued ID tokens.

### Firestore Security Rules

Firestore rules restrict read and write access to authenticated users only.

Role-based access control is enforced using user roles (e.g., admin).

Sensitive collections and operations (such as admin dashboards and data management) are protected from unauthorized access.

Rules validate user permissions before allowing data modifications.

### Security Benefits

Prevents unauthorized data access

Protects sensitive admin-only operations

Ensures data integrity by validating user identity and roles

Reduces risk of client-side manipulation

### Outcome

With these measures in place, the application follows Firebase security best practices, providing a safer and more reliable backend for both users and administrators.