**Fixora – Smart Urban Grievance Redressal System**

Fixora is a centralized, transparent, and real-time grievance redressal system designed to help Urban Local Bodies efficiently address citizen complaints. Built using Flutter for cross-platform accessibility and Firebase for seamless backend operations, Fixora enables users to easily submit issues while allowing authorities to track, manage, and resolve them with complete accountability.

## Folder Structure

lib/
│
├── main.dart
│
├── screens/
│   │
│   ├── auth/
│   │   ├── login_page.dart
│   │   └── register_page.dart
│   │
│   ├── user/
│   │   ├── user_dashboard.dart
│   │   ├── submit_complaint_page.dart
│   │   ├── tracking_complaint_page.dart
│   │   ├── complaint_categories_page.dart
│   │   └── user_profile_page.dart
│   │
│   ├── admin/
│   │   └── admin_dashboard_page.dart
│   │
│   ├── common/
│   │   └── home_page.dart
│   │
│   └── splash/
│       └── splash_screen.dart
│
├── widgets/
│   ├── custom_button.dart
│   ├── custom_textfield.dart
│   ├── complaint_card.dart
│   └── dashboard_tile.dart
│
├── models/
│   ├── user_model.dart
│   └── complaint_model.dart
│
├── services/
│   ├── auth_service.dart
│   ├── complaint_service.dart
│   ├── admin_service.dart
│   └── firestore_service.dart
│
├── utils/
│   ├── app_colors.dart
│   ├── app_styles.dart
│   ├── app_routes.dart
│   └── constants.dart
│
└── providers/
    ├── user_provider.dart
    └── complaint_provider.dart


## Flutter & Dart Basics (Concept 1)

# 1. StatelessWidget vs StatefulWidget

StatelessWidget:

Does not change once it is built.

Used for static UI like text, icons, simple layouts.

StatefulWidget:

Can change during the app’s lifetime.

Used when the UI updates, like counters, text fields, or API data.

# 2. How Flutter Uses the Widget Tree

Flutter builds everything as a widget tree.

Each widget is a small part of the UI.

When something changes (like a button press), Flutter rebuilds only the affected widgets.

This makes the UI fast and reactive.

# 3. Why Dart Is Ideal for Flutter

Dart compiles fast and gives smooth performance.

Supports hot reload, so changes appear instantly.

Works well for both UI and logic, making development simple.

# 4. Demo App Notes (Android / iOS)

Our demo app showed a simple screen with text and a button.

Pressing the button updated the counter (StatefulWidget).

Screenshot -1
**Refer to screenshot folder for proof of work(concept-1.png)**

### Firebase & Firestore Basics (Concept 2)

**1. Steps Followed for Firebase Setup**

Created a new project in Firebase Console.

Enabled Firestore Database.

Added Firebase to the Flutter app using the setup instructions.

Downloaded the google-services.json (Android) / GoogleService-Info.plist (iOS).

Added required Firebase dependencies in pubspec.yaml.

Initialized Firebase in the app using Firebase.initializeApp().

**2.How Firestore’s Real-Time Sync Works**

Firestore sends updates to the app instantly whenever data changes.

The app listens to the database using streams (like StreamBuilder).

No need to refresh—the UI updates automatically when Firestore data changes.

This works because Firestore uses real-time listeners under the hood.

**Demo Logs / Notes Showing Live Updates**

**Refer to screenshot folder for proof of work(concept-2.png)**

**4. Reflection – How Firebase Simplified Backend Management**

No need to build your own server or database.

Firestore handled real-time data, storage, and syncing for us.

Authentication, hosting, and database all came ready to use.

This allowed us to focus more on UI and features instead of backend code.

Firebase helped build a working mobile app much faster and with less complexity.

## Authentication & User Dashboard (Concept 2.5)

**Overview: Login, Register & Dashboard Implementation**

We have created a complete authentication flow with responsive UI for mobile, tablet, and desktop devices.

**1. Login & Register Pages**

Created `login_register_page.dart` with the following features:

- **Dual Form UI**: Single component handles both login and registration modes
- **Form Validation**: Email and password validation with error messages
- **Responsive Design**: Adaptive UI that adjusts padding, font sizes, and button heights based on screen size
- **Form Switching**: Easy toggle between login and register modes using the "Don't have an account?" / "Already have an account?" buttons
- **Flutter StatefulWidget**: Uses form validation with GlobalKey to ensure user inputs are valid before submission

**Key Features:**

- Input validation for email, password, and username (registration only)
- Responsive card design with elevation effects
- Centered layout using SingleChildScrollView and ConstrainedBox
- TextFormField for email (with keyboard type), password (obscured), and username
- ElevatedButton with dynamic sizing

**Screenshots:**

- Login Screen: `screenshot/login_screen.png`
- Register Screen: `screenshot/register_screen.png`
- Home Screen: `screenshot/home_screen.png`

**2. User Dashboard**

Created `user_dashboard.dart` with the following features:

- **Welcome Message**: Personalized greeting with user icon
- **Account Information Display**: Shows logged-in user's email and username
- **Logout Functionality**: Profile menu button in AppBar with logout confirmation dialog
- **Responsive Layout**: Matches login page design for consistency
- **Navigation Integration**: Receives user data via route arguments

**Key Features:**

- Displays user email and username from login/register form
- PopupMenuButton for user profile actions
- Confirmation dialog before logout
- Clears navigation history on logout (user cannot go back to dashboard)
- Professional card-based UI with proper spacing
- Fully responsive for all screen sizes

**Navigation Flow:**

1. Home Page → "Login / Register" button
2. Login/Register Page → Enter credentials → "Login" or "Register" button
3. User Dashboard → Shows welcome message + user info
4. Logout → Returns to Home Page

## Figma & Design Thinking (Concept 3)

Concept 3 : [Concept-3] Design Thinking for Smart Mobile Interfaces Using Figma & Flutter

Figma link added in README: https://www.figma.com/design/oVfHrUu16qlP7QhvimqI5o/Untitled?node-id=21-2&t=mO2EKGZKPWgBHT9P-1

Creating the High-Level Design (HLD) for Fixora

The High-Level Design (HLD) gives an overview of how the Urban Grievance Redressal System is structured. It explains the main parts of the app, how they connect, and how data flows through the system. This helps in understanding the project’s architecture before moving into detailed implementation.

What the HLD Includes

1. Frontend (Flutter App)

Main screens: Splash, Login, Dashboard, Add Complaint, Complaint Status, Profile.

Simple navigation flow between screens.

Use of state management (like Provider, Riverpod, or Bloc).

Reusable UI components for consistency.

2. Backend (Firebase Services)

Firebase Authentication for secure login (Email/Google).

Cloud Firestore to store user data, complaints, and status updates.

Cloud Storage for uploading photos/videos of issues.

Cloud Functions for sending notifications and automating backend tasks.

3. Data Models

User: id, name, email, role.

Complaint: title, description, category, location, media, status, timestamps.

Updates: timeline of changes for each complaint.

4. Integrations

Google Maps API for selecting and viewing locations.

Firebase Cloud Messaging (FCM) for real-time notifications.

Analytics & Crashlytics for tracking usage and app crashes.

5. CI/CD & Deployment

Automated build and deploy pipelines using GitHub Actions or Codemagic.

Support for multiple environments (dev / staging / production).

The HLD also includes a visual diagram showing how all layers connect.

Here is the figma link:

https://www.figma.com/design/oVfHrUu16qlP7QhvimqI5o/Untitled?node-id=19-2&t=tA9gbpPbYfdawzYP-1
