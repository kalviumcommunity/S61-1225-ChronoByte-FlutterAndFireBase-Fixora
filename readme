**Fixora – Smart Urban Grievance Redressal System**

Fixora is a centralized, transparent, and real-time grievance redressal system designed to help Urban Local Bodies efficiently address citizen complaints. Built using Flutter for cross-platform accessibility and Firebase for seamless backend operations, Fixora enables users to easily submit issues while allowing authorities to track, manage, and resolve them with complete accountability.

---

## Setting Up Flutter SDK, Android Studio, and First Emulator Run

Welcome to your first setup deliverable of Sprint #2! In this foundational task, you'll install and configure the Flutter SDK, set up Android Studio (or VS Code) for development, and run your first Flutter app on an emulator or physical device. This step establishes your complete development environment for all upcoming Flutter and Firebase integrations in this sprint.

**Note:** These are general setup guidelines. You may complete the setup on Windows, macOS, or Linux, depending on your system preferences and requirements.

### Task Overview

**1. Install Flutter SDK**

- Visit the official Flutter installation page for your operating system.
- Download and extract the Flutter SDK to a preferred directory (e.g., `C:\src\flutter` or `/Users/yourname/development/flutter`).
- Add Flutter to your systems PATH environment variable.

**Windows:**
- Search for "Environment Variables" → Edit PATH → Add `flutter\bin`.

**macOS/Linux:**
- Open terminal and edit your shell profile (e.g., `.zshrc` or `.bashrc`):
    bash
  export PATH="$PATH:`pwd`/flutter/bin"

- Verify installation by running:
  ```bash
  flutter doctor
  ```
  This command checks your setup and lists missing dependencies.

**2. Set Up Android Studio (or VS Code)**

- Install Android Studio from the official website.
- During installation, ensure the following components are checked:
  - Android SDK
  - Android SDK Platform
  - Android Virtual Device (AVD) Manager
- Open Android Studio → Plugins → search for and install Flutter and Dart plugins.

**Alternatively, if using VS Code:**
- Install Flutter and Dart extensions from the Marketplace.

**3. Configure Your Emulator**

In Android Studio:
- Open AVD Manager → Create Virtual Device.
- Choose a device (e.g., Pixel 6) and a system image (Android 13 or above).
- Click Finish and launch the emulator.

Verify that your emulator is detected by running:

```
bash
flutter devices
```
The emulator should appear in the device list.

**4. Create and Run Your First Flutter App**

- Create a new Flutter project:

  ```bash
  flutter create first_flutter_app
  ```
- Navigate to the project folder and open it in Android Studio or VS Code.
- Run the app on your emulator or connected physical device:

  ```bash
  flutter run
  ```
- You should see the default Flutter counter app appear on your emulator screen.

**5. Setup Verification**

We have successfully completed the Flutter environment setup with the following evidence:

- **Flutter Doctor Output**: All required dependencies are installed and configured correctly
- **Emulator Running**: The Android emulator is successfully running the first Flutter app

**Screenshots:**
- Flutter Devices Detection: `screenshot/result_of_flutter_device.png`
- Android Emulator Running: `screenshot/android_emulator.png`

**Setup Completion Notes:**
- Flutter SDK has been successfully installed and added to PATH
- Android Studio configured with Flutter and Dart plugins
- Android Virtual Device (AVD) created and tested
- First Flutter app successfully runs on the emulator
- Development environment is ready for upcoming Flutter and Firebase integrations


## Folder Structure

lib/
│
├── main.dart
│
├── screens/
│   │
│   ├── auth/
│   │   ├── login_page.dart
│   │   └── register_page.dart
│   │
│   ├── user/
│   │   ├── user_dashboard.dart
│   │   ├── submit_complaint_page.dart
│   │   ├── tracking_complaint_page.dart
│   │   ├── complaint_categories_page.dart
│   │   └── user_profile_page.dart
│   │
│   ├── admin/
│   │   └── admin_dashboard_page.dart
│   │
│   ├── common/
│   │   └── home_page.dart
│   │
│   └── splash/
│       └── splash_screen.dart
│
├── widgets/
│   ├── custom_button.dart
│   ├── custom_textfield.dart
│   ├── complaint_card.dart
│   └── dashboard_tile.dart
│
├── models/
│   ├── user_model.dart
│   └── complaint_model.dart
│
├── services/
│   ├── auth_service.dart
│   ├── complaint_service.dart
│   ├── admin_service.dart
│   └── firestore_service.dart
│
├── utils/
│   ├── app_colors.dart
│   ├── app_styles.dart
│   ├── app_routes.dart
│   └── constants.dart
│
└── providers/
    ├── user_provider.dart
    └── complaint_provider.dart

## Exploring Flutter Project Folder Structure and Understanding File Roles

## Project Title

Flutter Project Folder Structure Overview

A simple project setup showcasing how the Flutter folder structure works and why understanding it helps in app development.

---

## Project Structure Summary

For a detailed explanation, check **PROJECT_STRUCTURE.md**.

```
lib/
├── main.dart
├── screens/
├── widgets/
└── services/
```

This is the main working directory where all Dart code lives.

---

## Folder View (IDE Screenshot Placeholder)

> Add your folder screenshot here.

---

## Reflection

### Why understand folder roles?

* Helps navigate the project faster.
* Makes it easier to debug and add new features.

### How does clean structure help teams?

* Every member knows where files belong.
* Reduces confusion and merge conflicts.
* Improves scalability and maintainability.


## Flutter & Dart Basics (Concept 1)

# 1. StatelessWidget vs StatefulWidget

StatelessWidget:

Does not change once it is built.

Used for static UI like text, icons, simple layouts.

StatefulWidget:

Can change during the app’s lifetime.

Used when the UI updates, like counters, text fields, or API data.

# 2. How Flutter Uses the Widget Tree

Flutter builds everything as a widget tree.

Each widget is a small part of the UI.

When something changes (like a button press), Flutter rebuilds only the affected widgets.

This makes the UI fast and reactive.

# 3. Why Dart Is Ideal for Flutter

Dart compiles fast and gives smooth performance.

Supports hot reload, so changes appear instantly.

Works well for both UI and logic, making development simple.

# 4. Demo App Notes (Android / iOS)

Our demo app showed a simple screen with text and a button.

Pressing the button updated the counter (StatefulWidget).

Screenshot -1
**Refer to screenshot folder for proof of work(concept-1.png)**

### Firebase & Firestore Basics (Concept 2)

**1. Steps Followed for Firebase Setup**

Created a new project in Firebase Console.

Enabled Firestore Database.

Added Firebase to the Flutter app using the setup instructions.

Downloaded the google-services.json (Android) / GoogleService-Info.plist (iOS).

Added required Firebase dependencies in pubspec.yaml.

Initialized Firebase in the app using Firebase.initializeApp().

**2.How Firestore’s Real-Time Sync Works**

Firestore sends updates to the app instantly whenever data changes.

The app listens to the database using streams (like StreamBuilder).

No need to refresh—the UI updates automatically when Firestore data changes.

This works because Firestore uses real-time listeners under the hood.

**Demo Logs / Notes Showing Live Updates**

**Refer to screenshot folder for proof of work(concept-2.png)**

**4. Reflection – How Firebase Simplified Backend Management**

No need to build your own server or database.

Firestore handled real-time data, storage, and syncing for us.

Authentication, hosting, and database all came ready to use.

This allowed us to focus more on UI and features instead of backend code.

Firebase helped build a working mobile app much faster and with less complexity.

Here is a **short, clean, human-written version** you can directly paste into your README:

---

## Flutter Development Tools Overview

### **1. Hot Reload**

Hot Reload lets you apply UI and code changes instantly without restarting the app.
Just run the app (`flutter run`), edit a widget, save the file, and the update appears immediately.
This makes UI development much faster and keeps the app state intact.
screenshot/hot_reload.png
screenshot/hot_reload_After.png

### **2. Debug Console**

I used the Debug Console to monitor logs, catch errors, and track variable changes using `print()` or `debugPrint()`.
It helps understand how the app behaves while running and is useful for quick debugging.

### **3. Flutter DevTools**

DevTools was used to inspect widgets, check layouts, view performance graphs, and analyze memory usage.
I opened it directly from VS Code using **Ctrl + Shift + P → Flutter: Open DevTools** while the app was running.
screenshot/dev_tools.png

### **4. Workflow**

My workflow was simple:

* Update UI → Hot Reload to see immediate changes
* Add logs → View results in Debug Console
* Open DevTools → Inspect widgets & performance

### **Reflection**

Hot Reload improved development speed, the Debug Console helped catch issues early, and DevTools made it easier to understand widget structure and optimize performance.


## Authentication & User Dashboard (Concept 2.5)

**Overview: Login, Register & Dashboard Implementation**

We have created a complete authentication flow with responsive UI for mobile, tablet, and desktop devices.

**1. Login & Register Pages**

Created `login_register_page.dart` with the following features:

- **Dual Form UI**: Single component handles both login and registration modes
- **Form Validation**: Email and password validation with error messages
- **Responsive Design**: Adaptive UI that adjusts padding, font sizes, and button heights based on screen size
- **Form Switching**: Easy toggle between login and register modes using the "Don't have an account?" / "Already have an account?" buttons
- **Flutter StatefulWidget**: Uses form validation with GlobalKey to ensure user inputs are valid before submission

**Key Features:**

- Input validation for email, password, and username (registration only)
- Responsive card design with elevation effects
- Centered layout using SingleChildScrollView and ConstrainedBox
- TextFormField for email (with keyboard type), password (obscured), and username
- ElevatedButton with dynamic sizing

**Screenshots:**

- Login Screen: `screenshot/login_screen.png`
- Register Screen: `screenshot/register_screen.png`
- Home Screen: `screenshot/home_screen.png`

**2. User Dashboard**

Created `user_dashboard.dart` with the following features:

- **Welcome Message**: Personalized greeting with user icon
- **Account Information Display**: Shows logged-in user's email and username
- **Logout Functionality**: Profile menu button in AppBar with logout confirmation dialog
- **Responsive Layout**: Matches login page design for consistency
- **Navigation Integration**: Receives user data via route arguments

**Key Features:**

- Displays user email and username from login/register form
- PopupMenuButton for user profile actions
- Confirmation dialog before logout
- Clears navigation history on logout (user cannot go back to dashboard)
- Professional card-based UI with proper spacing
- Fully responsive for all screen sizes

**Navigation Flow:**

1. Home Page → "Login / Register" button
2. Login/Register Page → Enter credentials → "Login" or "Register" button
3. User Dashboard → Shows welcome message + user info
4. Logout → Returns to Home Page

## Figma & Design Thinking (Concept 3)

Concept 3 : [Concept-3] Design Thinking for Smart Mobile Interfaces Using Figma & Flutter

Figma link added in README: https://www.figma.com/design/oVfHrUu16qlP7QhvimqI5o/Untitled?node-id=21-2&t=mO2EKGZKPWgBHT9P-1

Creating the High-Level Design (HLD) for Fixora

The High-Level Design (HLD) gives an overview of how the Urban Grievance Redressal System is structured. It explains the main parts of the app, how they connect, and how data flows through the system. This helps in understanding the project’s architecture before moving into detailed implementation.

What the HLD Includes

1. Frontend (Flutter App)

Main screens: Splash, Login, Dashboard, Add Complaint, Complaint Status, Profile.

Simple navigation flow between screens.

Use of state management (like Provider, Riverpod, or Bloc).

Reusable UI components for consistency.

2. Backend (Firebase Services)

Firebase Authentication for secure login (Email/Google).

Cloud Firestore to store user data, complaints, and status updates.

Cloud Storage for uploading photos/videos of issues.

Cloud Functions for sending notifications and automating backend tasks.

3. Data Models

User: id, name, email, role.

Complaint: title, description, category, location, media, status, timestamps.

Updates: timeline of changes for each complaint.

4. Integrations

Google Maps API for selecting and viewing locations.

Firebase Cloud Messaging (FCM) for real-time notifications.

Analytics & Crashlytics for tracking usage and app crashes.

5. CI/CD & Deployment

Automated build and deploy pipelines using GitHub Actions or Codemagic.

Support for multiple environments (dev / staging / production).

The HLD also includes a visual diagram showing how all layers connect.

Here is the figma link:

https://www.figma.com/design/oVfHrUu16qlP7QhvimqI5o/Untitled?node-id=19-2&t=tA9gbpPbYfdawzYP-1
